---
phase: 03-market-data-service
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - backend/app/market_data/stream_manager.py
  - backend/app/market_data/connection_manager.py
  - backend/app/market_data/router.py
  - backend/app/main.py
autonomous: true
requirements: [DATA-01, DATA-02, DATA-03, DATA-04]

must_haves:
  truths:
    - "Frontend can connect to backend WebSocket and receive real-time crypto price updates from Binance"
    - "Frontend can connect to backend WebSocket and receive real-time forex price updates from Twelve Data"
    - "Frontend can fetch historical candles via REST endpoint for any supported symbol and timeframe"
    - "Backend fans out upstream provider data to all subscribed frontend clients"
    - "Backend reconnects to upstream providers automatically on disconnect"
  artifacts:
    - path: "backend/app/market_data/stream_manager.py"
      provides: "Upstream provider WebSocket connection management and fan-out"
      contains: "class StreamManager"
    - path: "backend/app/market_data/connection_manager.py"
      provides: "Frontend WebSocket connection tracking and subscription management"
      contains: "class ConnectionManager"
    - path: "backend/app/market_data/router.py"
      provides: "WebSocket endpoint + REST endpoints for market data"
      contains: "websocket_endpoint"
    - path: "backend/app/main.py"
      provides: "Market data router registered"
      contains: "market_data"
  key_links:
    - from: "backend/app/market_data/router.py"
      to: "backend/app/market_data/stream_manager.py"
      via: "Router delegates subscriptions to stream manager"
      pattern: "stream_manager.*subscribe"
    - from: "backend/app/market_data/router.py"
      to: "backend/app/market_data/service.py"
      via: "Router uses service for historical data"
      pattern: "service.*get_historical"
    - from: "backend/app/market_data/stream_manager.py"
      to: "backend/app/market_data/providers/binance.py"
      via: "Connects to Binance WS upstream"
      pattern: "wss://stream.binance.com"
    - from: "backend/app/main.py"
      to: "backend/app/market_data/router.py"
      via: "Router included in FastAPI app"
      pattern: "include_router.*market_data"
---

<objective>
Build the backend WebSocket relay and REST endpoints: a stream manager that connects to upstream Binance and Twelve Data WebSocket feeds and fans out price updates to frontend clients, a connection manager tracking frontend subscriptions, and REST endpoints for historical data fetching.

Purpose: This is the core data pipeline -- the backend relay that bridges external market data providers to the frontend charts. It protects API keys, enables shared upstream connections across users, and centralizes rate limit management.

Output: A fully functional WebSocket endpoint that frontend can connect to for real-time price streams, and REST endpoints for historical candle data.
</objective>

<execution_context>
@/Users/heispv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heispv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-market-data-service/03-RESEARCH.md
@.planning/phases/03-market-data-service/03-01-SUMMARY.md

# Existing backend patterns
@backend/app/main.py
@backend/app/watchlists/router.py
@backend/app/database.py
@backend/app/config.py
@backend/app/market_data/schemas.py
@backend/app/market_data/providers/binance.py
@backend/app/market_data/providers/twelve_data.py
@backend/app/market_data/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stream manager and connection manager for WebSocket relay</name>
  <files>
    backend/app/market_data/stream_manager.py
    backend/app/market_data/connection_manager.py
  </files>
  <action>
    **1. Create connection manager (`backend/app/market_data/connection_manager.py`):**
    Class `ConnectionManager` tracking frontend WebSocket connections:
    - `_connections: dict[WebSocket, set[str]]` -- maps each frontend WS to its set of subscribed keys ("symbol@interval")
    - `_subscriptions: dict[str, set[WebSocket]]` -- reverse map: key -> set of subscribed frontend connections
    - `connect(ws: WebSocket)`: accept the WebSocket, add to _connections with empty set
    - `disconnect(ws: WebSocket)`: remove from all subscription sets, remove from _connections
    - `subscribe(ws: WebSocket, symbol: str, interval: str) -> bool`: add key to both maps. Return True if this is the first subscriber for this key (stream manager needs to start upstream).
    - `unsubscribe(ws: WebSocket, symbol: str, interval: str) -> bool`: remove from both maps. Return True if no subscribers remain for this key (stream manager can stop upstream).
    - `get_subscribers(key: str) -> set[WebSocket]`: return subscribers for a key
    - `get_all_keys() -> set[str]`: return all keys with at least one subscriber
    - `has_subscribers(key: str) -> bool`: check if any subscribers for key

    **2. Create stream manager (`backend/app/market_data/stream_manager.py`):**
    Class `StreamManager` managing upstream provider connections:
    - Constructor takes `connection_manager: ConnectionManager`
    - `_upstream_tasks: dict[str, asyncio.Task]` -- running upstream connection tasks per key
    - `_running: bool` -- lifecycle flag

    **`start_stream(symbol: str, interval: str)`:**
    - Build key = "symbol@interval"
    - If task already running for this key, skip
    - Detect asset class from symbol
    - Create asyncio.Task for _run_crypto_stream or _run_forex_stream
    - Store in _upstream_tasks

    **`stop_stream(symbol: str, interval: str)`:**
    - Cancel the task for this key
    - Remove from _upstream_tasks

    **`_run_crypto_stream(symbol: str, interval: str)`:**
    - Connect to Binance WS: `wss://stream.binance.com:9443/ws/{symbol.lower()}@kline_{binance_interval}`
    - Use `websockets.connect()` with ping_interval=20, ping_timeout=10
    - On each message: parse JSON, extract kline data (k field), build PriceUpdate with:
      - time = k["t"] // 1000 (ms to seconds)
      - open/high/low/close = float(k["o"/"h"/"l"/"c"])
      - volume = float(k["v"])
      - is_closed = k["x"]
    - Fan out: for each subscriber of this key, send the PriceUpdate as JSON via ws.send_json()
    - Remove dead clients on send failure
    - On disconnect: log, wait (exponential backoff: 1s initial, 30s max, with jitter), reconnect
    - Loop forever (while self._running)

    **`_run_forex_stream(symbol: str, interval: str)`:**
    - For forex, use REST polling approach (per research recommendation -- Twelve Data WS sends ticks, not candles; tick-to-candle aggregation is complex and deferred):
      - Poll `TwelveDataProvider.fetch_historical()` every 30 seconds for the latest candle
      - Compare with last known candle; if different (price changed), fan out as PriceUpdate with is_closed=False
      - When a new candle timestamp appears, mark previous as is_closed=True and send, then send new candle
    - Respect rate limits: 800 calls/day = ~33/hour = one call every ~108 seconds per pair. With 30s polling for the active pair, budget ~2880 calls/day for one pair. Limit to polling only the actively viewed forex pair.
    - On error: log, backoff, retry

    **`shutdown()`:**
    - Set _running = False
    - Cancel all upstream tasks
    - Await task cancellation
  </action>
  <verify>
    - `cd backend && python -c "from app.market_data.stream_manager import StreamManager; print('stream ok')"` succeeds
    - `cd backend && python -c "from app.market_data.connection_manager import ConnectionManager; print('conn ok')"` succeeds
    - ConnectionManager correctly tracks subscribe/unsubscribe returning first/last subscriber booleans
  </verify>
  <done>
    StreamManager connects to Binance WS for crypto and polls Twelve Data REST for forex, fanning out PriceUpdate messages to subscribed frontend clients. ConnectionManager tracks per-client subscriptions with efficient reverse lookups.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket and REST API endpoints, register router</name>
  <files>
    backend/app/market_data/router.py
    backend/app/main.py
  </files>
  <action>
    **1. Create market data router (`backend/app/market_data/router.py`):**
    Use FastAPI APIRouter with prefix="/api/v1/market-data" and tags=["market-data"].

    **Singleton instances:** Create module-level ConnectionManager and StreamManager instances. Initialize in the router module so they persist across requests.

    **WebSocket endpoint `@router.websocket("/ws")`:**
    - Accept the WebSocket connection via connection_manager.connect(ws)
    - Send initial ConnectionStatusMessage with status="connected"
    - Loop receiving JSON messages from client:
      - Parse as SubscribeMessage
      - If action == "subscribe":
        - connection_manager.subscribe(ws, symbol, interval)
        - If first subscriber: stream_manager.start_stream(symbol, interval)
        - Send SubscriptionConfirm back to client
      - If action == "unsubscribe":
        - If last subscriber: stream_manager.stop_stream(symbol, interval)
        - connection_manager.unsubscribe(ws, symbol, interval)
        - Send SubscriptionConfirm back to client
    - On WebSocketDisconnect: connection_manager.disconnect(ws), stop any streams with no remaining subscribers
    - On Exception: log error, disconnect

    **REST endpoint `GET /history`:**
    - Query params: symbol (str), interval (str), start_time (int | None), end_time (int | None), limit (int = 500)
    - Create MarketDataService with DB session (use Depends(get_db))
    - Call service.get_historical_candles()
    - Return HistoricalResponse

    **REST endpoint `GET /symbols`:**
    - Query param: asset_class (str, "crypto" or "forex")
    - Create MarketDataService with DB session
    - Call service.get_available_symbols()
    - Return list[str]

    **2. Register router in main.py:**
    - Import: `from app.market_data.router import router as market_data_router`
    - Add: `app.include_router(market_data_router)`
    - In the lifespan function, add shutdown logic:
      - In the yield block's cleanup (after yield), call `stream_manager.shutdown()` to cleanly close upstream connections
      - Import stream_manager from router module

    **3. Add lifespan startup for stream manager:**
    - In the lifespan function (before yield), initialize the stream_manager's _running flag to True
    - Import the stream_manager singleton from the router module
  </action>
  <verify>
    - `cd backend && python -c "from app.market_data.router import router; print(router.prefix)"` prints "/api/v1/market-data"
    - `cd backend && python -c "from app.main import app; routes = [r.path for r in app.routes]; print('/api/v1/market-data/ws' in str(routes) or '/api/v1/market-data/history' in str(routes))"` confirms routes registered
    - `cd backend && uvicorn app.main:app --host 0.0.0.0 --port 8000 &` starts without import errors (kill after verification)
  </verify>
  <done>
    Backend WebSocket endpoint at /api/v1/market-data/ws accepts frontend connections and relays real-time data. REST endpoints at /history and /symbols serve historical data and available symbols. All registered in FastAPI app with proper lifespan management.
  </done>
</task>

</tasks>

<verification>
1. Backend starts without import errors
2. WebSocket endpoint accessible at ws://localhost:8000/api/v1/market-data/ws
3. GET /api/v1/market-data/symbols?asset_class=crypto returns symbol list
4. GET /api/v1/market-data/history?symbol=BTCUSDT&interval=1d&limit=10 returns candle data (when Binance reachable)
5. Stream manager creates upstream Binance WS connection on first subscriber
6. Stream manager polls Twelve Data REST for forex on first subscriber
7. Connection manager correctly tracks client subscriptions
</verification>

<success_criteria>
- WebSocket relay is functional: subscribe message triggers upstream connection, price updates fan out to clients
- REST history endpoint returns cached or freshly fetched candle data
- Symbols endpoint returns available crypto and forex pairs
- Stream manager reconnects to upstream on disconnect with exponential backoff
- All routes registered in FastAPI app
- Lifespan handles clean startup and shutdown of stream manager
</success_criteria>

<output>
After completion, create `.planning/phases/03-market-data-service/03-03-SUMMARY.md`
</output>
