---
phase: 03-market-data-service
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/market-data.ts
  - frontend/src/stores/market-data-store.ts
  - frontend/src/hooks/use-market-data.ts
  - frontend/src/lib/market-data-api.ts
  - frontend/src/types/chart.ts
autonomous: true
requirements: [DATA-04]

must_haves:
  truths:
    - "Frontend can establish a WebSocket connection with automatic reconnection on disconnect"
    - "Connection status is tracked (connecting, connected, disconnected, reconnecting) and accessible via Zustand store"
    - "Frontend can send subscribe/unsubscribe messages for symbol+interval pairs over the WebSocket"
    - "REST helper can fetch historical candles from the backend API"
  artifacts:
    - path: "frontend/src/types/market-data.ts"
      provides: "TypeScript types for WebSocket messages and market data"
      contains: "PriceUpdate"
    - path: "frontend/src/stores/market-data-store.ts"
      provides: "Zustand store for connection state and price cache"
      contains: "useMarketDataStore"
    - path: "frontend/src/hooks/use-market-data.ts"
      provides: "WebSocket hook with reconnection logic"
      contains: "useMarketDataConnection"
    - path: "frontend/src/lib/market-data-api.ts"
      provides: "REST API helpers for historical data"
      contains: "fetchHistoricalCandles"
  key_links:
    - from: "frontend/src/hooks/use-market-data.ts"
      to: "frontend/src/stores/market-data-store.ts"
      via: "Hook updates store on WS events"
      pattern: "useMarketDataStore"
    - from: "frontend/src/stores/market-data-store.ts"
      to: "frontend/src/types/market-data.ts"
      via: "Store uses market data types"
      pattern: "import.*market-data"
---

<objective>
Build the frontend market data layer: TypeScript types for WebSocket messages and provider data, a Zustand store for connection state and price cache, a WebSocket hook with exponential backoff reconnection, and REST API helpers for fetching historical candles.

Purpose: Create the client-side data infrastructure that Plan 04 will wire into the chart components. Separating this layer allows the WebSocket connection management and state to be developed and tested independently of the chart rendering integration.

Output: Importable types, store, hook, and API helpers ready for consumption by chart-container and watchlist components.
</objective>

<execution_context>
@/Users/heispv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heispv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-market-data-service/03-RESEARCH.md

# Existing frontend patterns
@frontend/src/types/chart.ts
@frontend/src/stores/chart-store.ts
@frontend/src/stores/watchlist-store.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create market data types and expand chart types for multi-asset support</name>
  <files>
    frontend/src/types/market-data.ts
    frontend/src/types/chart.ts
  </files>
  <action>
    **1. Create market data types (`frontend/src/types/market-data.ts`):**

    ```typescript
    // --- Asset Classification ---
    export type AssetClass = "crypto" | "forex";

    export function detectAssetClass(symbol: string): AssetClass {
      return symbol.includes("/") ? "forex" : "crypto";
    }

    // --- WebSocket Message Types ---

    /** Client -> Server: subscribe/unsubscribe to a symbol stream */
    export interface SubscribeMessage {
      action: "subscribe" | "unsubscribe";
      symbol: string;
      interval: string;
    }

    /** Server -> Client: real-time candle update */
    export interface PriceUpdate {
      type: "price_update";
      symbol: string;
      interval: string;
      candle: {
        time: number;   // Unix seconds
        open: number;
        high: number;
        low: number;
        close: number;
        volume: number;
      };
      is_closed: boolean;
    }

    /** Server -> Client: connection status notification */
    export interface ConnectionStatusMessage {
      type: "connection_status";
      status: "connected" | "reconnecting" | "error";
      message?: string;
    }

    /** Server -> Client: subscription confirmation */
    export interface SubscriptionConfirm {
      type: "subscribed" | "unsubscribed";
      symbol: string;
      interval: string;
    }

    /** Union of all server -> client message types */
    export type ServerMessage = PriceUpdate | ConnectionStatusMessage | SubscriptionConfirm;

    // --- Connection State ---
    export type ConnectionStatus = "connecting" | "connected" | "disconnected" | "reconnecting";

    // --- Historical Data ---
    export interface OHLCVCandle {
      time: number;
      open: number;
      high: number;
      low: number;
      close: number;
      volume: number;
    }

    export interface HistoricalResponse {
      symbol: string;
      interval: string;
      candles: OHLCVCandle[];
    }
    ```

    **2. Expand chart types (`frontend/src/types/chart.ts`):**
    - Add `FOREX_SYMBOLS` array with ~25 forex pairs. Each entry: `{ symbol: "EUR/USD", name: "Euro / US Dollar" }` (no basePrice/volatility since those were mock-data-specific). Use a simpler `ForexSymbol` interface: `{ symbol: string; name: string }`.
    - Add `type SymbolInfo = CryptoSymbol | ForexSymbol` union type.
    - Keep `CRYPTO_SYMBOLS` and `CryptoSymbol` unchanged (they remain useful for fallback/dev mode).
    - Add forex major pairs: EUR/USD, GBP/USD, USD/JPY, USD/CHF, AUD/USD, NZD/USD, USD/CAD.
    - Add forex minor pairs: EUR/GBP, EUR/JPY, GBP/JPY, AUD/JPY, EUR/AUD, GBP/AUD, EUR/CAD, GBP/CAD, AUD/NZD, EUR/NZD, CHF/JPY, CAD/JPY, NZD/JPY, EUR/CHF, GBP/CHF, AUD/CAD, NZD/CAD, GBP/NZD.
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - Types file exports PriceUpdate, ConnectionStatus, SubscribeMessage, OHLCVCandle
    - chart.ts exports FOREX_SYMBOLS with 25 pairs
  </verify>
  <done>
    All market data TypeScript types defined. Chart types expanded with forex symbol definitions. detectAssetClass correctly distinguishes crypto ("BTCUSDT") from forex ("EUR/USD").
  </done>
</task>

<task type="auto">
  <name>Task 2: Create market data Zustand store, WebSocket hook, and REST API helpers</name>
  <files>
    frontend/src/stores/market-data-store.ts
    frontend/src/hooks/use-market-data.ts
    frontend/src/lib/market-data-api.ts
  </files>
  <action>
    **1. Create market data Zustand store (`frontend/src/stores/market-data-store.ts`):**
    No persist middleware (like watchlist-store pattern -- data is transient/live).

    State:
    - `connectionStatus: ConnectionStatus` (initially "disconnected")
    - `reconnectAttempt: number` (0)
    - `lastConnected: number | null` (null)
    - `activeSubscriptions: Set<string>` (set of "symbol@interval" keys)
    - `latestPrices: Map<string, OHLCVCandle>` (keyed by symbol, latest candle for watchlist display)

    Actions:
    - `setConnectionStatus(status: ConnectionStatus)` -- also reset reconnectAttempt to 0 when status is "connected", set lastConnected to Date.now()
    - `incrementReconnectAttempt()` -- increment reconnectAttempt
    - `addSubscription(symbol: string, interval: string)` -- add "symbol@interval" to activeSubscriptions
    - `removeSubscription(symbol: string, interval: string)` -- remove from activeSubscriptions
    - `clearSubscriptions()` -- clear all
    - `updateLatestPrice(symbol: string, candle: OHLCVCandle)` -- set in latestPrices map
    - `getLatestPrice(symbol: string) -> OHLCVCandle | undefined` -- get from latestPrices

    **2. Create WebSocket hook (`frontend/src/hooks/use-market-data.ts`):**
    `useMarketDataConnection()` hook:
    - Gets WS URL from environment: `process.env.NEXT_PUBLIC_WS_URL || "ws://localhost:8000/api/v1/market-data/ws"` (fallback for dev)
    - Manages WebSocket lifecycle with useRef for ws instance
    - On open: call store.setConnectionStatus("connected"), re-subscribe to all activeSubscriptions
    - On message: parse JSON, dispatch based on type field:
      - "price_update": call store.updateLatestPrice() and invoke onPriceUpdate callback (passed as option)
      - "connection_status": log and update store
      - "subscribed"/"unsubscribed": log confirmation
    - On close: call store.setConnectionStatus("reconnecting"), store.incrementReconnectAttempt(), schedule reconnect
    - On error: log error

    Reconnection logic:
    - Exponential backoff: `Math.min(1000 * Math.pow(2, attempt), 30000) + Math.random() * 1000`
    - Never stop retrying
    - After 5 failed attempts, set status to "disconnected" (banner changes color)

    Expose:
    - `subscribe(symbol: string, interval: string)`: send SubscribeMessage via ws, add to store
    - `unsubscribe(symbol: string, interval: string)`: send SubscribeMessage via ws, remove from store
    - `connectionStatus`: from store
    - `isConnected`: derived boolean

    Cleanup: close WebSocket on unmount, clear reconnect timeout.

    **3. Create REST API helpers (`frontend/src/lib/market-data-api.ts`):**
    Using the existing api.ts pattern (apiGet):
    - `fetchHistoricalCandles(symbol: string, interval: string, options?: { startTime?: number; endTime?: number; limit?: number }): Promise<OHLCVCandle[]>` -- calls `GET /api/v1/market-data/history?symbol=X&interval=Y&start_time=Z&end_time=W&limit=N`, returns candles array from HistoricalResponse.
    - `fetchAvailableSymbols(assetClass: "crypto" | "forex"): Promise<string[]>` -- calls `GET /api/v1/market-data/symbols?asset_class=X`, returns string array.
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - Store exports useMarketDataStore
    - Hook exports useMarketDataConnection, subscribe, unsubscribe
    - API helpers export fetchHistoricalCandles, fetchAvailableSymbols
  </verify>
  <done>
    Market data Zustand store tracks connection status and latest prices. WebSocket hook manages connection lifecycle with exponential backoff reconnection. REST helpers provide typed access to historical data and symbol list endpoints.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes with no errors across all new and modified files
2. All new types, store, hook, and API functions are importable
3. detectAssetClass correctly identifies "BTCUSDT" as crypto and "EUR/USD" as forex
4. FOREX_SYMBOLS contains ~25 major and minor pairs
5. Store initializes with "disconnected" status and empty subscriptions
</verification>

<success_criteria>
- All TypeScript types compile cleanly
- Market data store provides connection state management without localStorage persistence
- WebSocket hook implements exponential backoff (1s initial, 30s max, with jitter)
- REST helpers match the backend API endpoint signatures from Plan 03
- Chart types expanded with ForexSymbol and FOREX_SYMBOLS array
</success_criteria>

<output>
After completion, create `.planning/phases/03-market-data-service/03-02-SUMMARY.md`
</output>
