---
phase: 03-market-data-service
plan: 04
type: execute
wave: 2
depends_on: [03-02, 03-03]
files_modified:
  - frontend/src/components/chart/chart-container.tsx
  - frontend/src/components/chart/connection-banner.tsx
  - frontend/src/components/chart/series-manager.ts
  - frontend/src/components/watchlist/watchlist-item.tsx
  - frontend/src/components/watchlist/symbol-search.tsx
  - frontend/src/stores/chart-store.ts
autonomous: true
requirements: [DATA-01, DATA-02, DATA-03, DATA-04]

must_haves:
  truths:
    - "User sees real-time crypto price updates on the chart without page refresh"
    - "User sees real-time forex price updates on the chart without page refresh"
    - "User can scroll back through years of history with candles loading seamlessly"
    - "Connection banner appears at top of chart when WebSocket disconnects and disappears on reconnect"
    - "Watchlist items display live prices from WebSocket stream instead of mock data"
    - "Switching timeframes maintains the same time position on the chart"
    - "Current candle smoothly updates OHLC as ticks arrive (not snapping)"
    - "Initial chart load displays ~500 candles as a generous buffer"
  artifacts:
    - path: "frontend/src/components/chart/chart-container.tsx"
      provides: "Chart wired to real market data with infinite scroll and live updates"
      contains: "useMarketDataConnection"
    - path: "frontend/src/components/chart/connection-banner.tsx"
      provides: "Connection status banner overlay"
      contains: "ConnectionBanner"
    - path: "frontend/src/components/chart/series-manager.ts"
      provides: "Updated with updateCandle and prependHistory functions"
      contains: "updateCandle"
    - path: "frontend/src/components/watchlist/watchlist-item.tsx"
      provides: "Live prices from market data store"
      contains: "useMarketDataStore"
  key_links:
    - from: "frontend/src/components/chart/chart-container.tsx"
      to: "frontend/src/hooks/use-market-data.ts"
      via: "Hook provides WS connection, subscribe, unsubscribe"
      pattern: "useMarketDataConnection"
    - from: "frontend/src/components/chart/chart-container.tsx"
      to: "frontend/src/lib/market-data-api.ts"
      via: "Fetches initial and historical candle data"
      pattern: "fetchHistoricalCandles"
    - from: "frontend/src/components/chart/chart-container.tsx"
      to: "frontend/src/components/chart/connection-banner.tsx"
      via: "Renders banner based on connection status"
      pattern: "ConnectionBanner"
    - from: "frontend/src/components/watchlist/watchlist-item.tsx"
      to: "frontend/src/stores/market-data-store.ts"
      via: "Reads latest prices from store"
      pattern: "useMarketDataStore.*getLatestPrice"
    - from: "frontend/src/components/chart/chart-container.tsx"
      to: "frontend/src/components/chart/series-manager.ts"
      via: "Uses updateCandle for real-time and prependHistory for infinite scroll"
      pattern: "updateCandle|prependHistory"
---

<objective>
Wire real market data into the chart and watchlist: replace mock data with live streaming prices and historical candle fetching, implement infinite scroll for history loading, add connection status banner, update watchlist to show live prices, and ensure smooth real-time candle animation.

Purpose: This is the user-facing integration that makes all the infrastructure from Plans 01-03 visible. Users will see live prices updating on their charts, scroll back through years of history, and see connection status feedback.

Output: A fully functional real-time chart experience with live crypto and forex data, infinite history scrolling, and connection status awareness.
</objective>

<execution_context>
@/Users/heispv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/heispv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-market-data-service/03-RESEARCH.md
@.planning/phases/03-market-data-service/03-01-SUMMARY.md
@.planning/phases/03-market-data-service/03-02-SUMMARY.md
@.planning/phases/03-market-data-service/03-03-SUMMARY.md

# Key existing files to modify
@frontend/src/components/chart/chart-container.tsx
@frontend/src/components/chart/series-manager.ts
@frontend/src/components/watchlist/watchlist-item.tsx
@frontend/src/components/watchlist/symbol-search.tsx
@frontend/src/stores/chart-store.ts
@frontend/src/lib/mock-data.ts
@frontend/src/types/chart.ts
@frontend/src/types/market-data.ts
@frontend/src/hooks/use-market-data.ts
@frontend/src/stores/market-data-store.ts
@frontend/src/lib/market-data-api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add series-manager real-time update functions, connection banner, and update chart store</name>
  <files>
    frontend/src/components/chart/series-manager.ts
    frontend/src/components/chart/connection-banner.tsx
    frontend/src/stores/chart-store.ts
  </files>
  <action>
    **1. Extend series-manager (`frontend/src/components/chart/series-manager.ts`):**

    Add new exported functions (do NOT remove existing ones -- addMainSeries and addVolumeSeries are still used for initial data load):

    **`updateCandle(mainSeries, volumeSeries, candle, chartType)`:**
    - Takes the main series ref, volume series ref, an OHLCVCandle object, and current chartType
    - For candlestick/ohlc/heikin-ashi: call `mainSeries.update({ time: castTime(candle.time), open, high, low, close })`
    - For line/area: call `mainSeries.update({ time: castTime(candle.time), value: candle.close })`
    - Volume: call `volumeSeries.update({ time: castTime(candle.time), value: candle.volume, color: candle.close >= candle.open ? "rgba(38, 166, 154, 0.5)" : "rgba(239, 83, 80, 0.5)" })`
    - This enables smooth real-time candle animation -- series.update() only modifies the last data point.

    **`prependHistory(mainSeries, volumeSeries, existingData, newHistory, chartType)`:**
    - Prepends newHistory candles to existingData
    - Calls `mainSeries.setData()` with combined dataset (properly formatted for chart type)
    - Calls `volumeSeries.setData()` with combined volume data
    - Returns the combined data array for caller to store
    - Does NOT call fitContent() -- caller must save/restore visible range

    **2. Create connection banner (`frontend/src/components/chart/connection-banner.tsx`):**
    A "use client" component:
    ```
    ConnectionBanner({ status }: { status: ConnectionStatus })
    ```
    - If status === "connected": return null (no banner)
    - "connecting": yellow/amber banner "Connecting to market data..."
    - "reconnecting": orange banner "Connection lost -- reconnecting..."
    - "disconnected": red banner "Market data disconnected. Check your connection."
    - Positioned absolute at top of chart area: `absolute top-0 left-0 right-0 z-30`
    - Small text (text-xs), centered, white text on colored background
    - Matches the locked decision: colored banner at top of chart area, NO chart dimming

    **3. Update chart store (`frontend/src/stores/chart-store.ts`):**
    Add a `dataSource` state field: `"mock" | "live"` with default `"live"`.
    Add action `setDataSource(source: "mock" | "live")`.
    This allows graceful fallback to mock data when backend is unreachable.
    Keep the existing mock data import in chart-container as fallback.
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - series-manager exports updateCandle and prependHistory
    - ConnectionBanner component renders correctly for each status
    - chart-store includes dataSource field
  </verify>
  <done>
    Series manager supports real-time single-bar updates and history prepending. Connection banner provides visual feedback for all connection states. Chart store has dataSource toggle for mock/live fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire chart-container to real data with infinite scroll and live updates</name>
  <files>
    frontend/src/components/chart/chart-container.tsx
  </files>
  <action>
    **Replace the data loading logic in ChartContainer:**

    **1. Add imports:**
    - Import `useMarketDataConnection` from hooks/use-market-data
    - Import `fetchHistoricalCandles` from lib/market-data-api
    - Import `ConnectionBanner` from chart/connection-banner
    - Import `useMarketDataStore` from stores/market-data-store
    - Import `updateCandle, prependHistory` from chart/series-manager
    - Import `OHLCVCandle` from types/market-data
    - Keep `getMockDataForSymbol` import as fallback

    **2. Add state refs:**
    - `currentDataRef = useRef<OHLCVCandle[]>([])` -- tracks current chart data for history prepending
    - `isLoadingHistoryRef = useRef(false)` -- prevents concurrent history fetches
    - `const INITIAL_CANDLE_COUNT = 500` -- generous buffer per user decision
    - `const HISTORY_FETCH_SIZE = 500` -- batch size for infinite scroll
    - `const SCROLL_THRESHOLD = 10` -- bars from left edge before loading more

    **3. Initialize WebSocket connection:**
    - Call `useMarketDataConnection()` at component top level
    - Get `subscribe, unsubscribe, connectionStatus` from the hook
    - Get `dataSource` from chart store

    **4. Replace data loading effect (the one with getMockDataForSymbol):**
    - When activeSymbol or activeTimeframe changes:
      - If dataSource === "mock": use getMockDataForSymbol as before (fallback)
      - If dataSource === "live":
        a. Unsubscribe from previous symbol/interval if any (track previous in ref)
        b. Keep old chart data visible (per user decision: no clearing)
        c. Fetch initial candles: `await fetchHistoricalCandles(activeSymbol, activeTimeframe, { limit: INITIAL_CANDLE_COUNT })`
        d. If fetch fails (backend unreachable), fall back to mock data and log warning
        e. If timeframe changed (not symbol): save current visible time range via `chart.timeScale().getVisibleRange()`, then after setData, restore with `chart.timeScale().setVisibleRange(savedRange)` -- this implements the "maintain same time position" user decision
        f. If symbol changed: call fitContent() after setData (show all loaded data)
        g. Clear series, add new series with fetched data (same pattern as current code)
        h. Store data in currentDataRef
        i. Subscribe to new symbol/interval via WebSocket

    **5. Add real-time update handler:**
    - In the useMarketDataConnection options, pass an `onPriceUpdate` callback:
      - Check that update.symbol matches activeSymbol and update.interval matches activeTimeframe
      - Call `updateCandle(mainSeriesRef, volumeSeriesRef, update.candle, chartType)` for smooth animation
      - If update.is_closed: append the candle to currentDataRef (new bar starts)

    **6. Add infinite scroll (history loading):**
    - After chart is created and initial data loaded, subscribe to `chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => ...)`
    - In the callback:
      - If logicalRange.from < SCROLL_THRESHOLD and !isLoadingHistoryRef.current:
        - Set isLoadingHistoryRef.current = true
        - Get oldest candle time from currentDataRef[0]
        - Fetch: `fetchHistoricalCandles(activeSymbol, activeTimeframe, { endTime: oldestTime - 1, limit: HISTORY_FETCH_SIZE })`
        - If data returned: save visible range, call prependHistory(), restore visible range
        - Set isLoadingHistoryRef.current = false

    **7. Add connection banner to render:**
    - Inside the chart canvas wrapper div (the `relative flex-1` div), add:
      `<ConnectionBanner status={connectionStatus} />`
    - Position it ABOVE the OHLC legend but within the chart area

    **8. Cleanup on unmount:**
    - Unsubscribe from current symbol/interval
    - Unsubscribe from visible range change listener
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - `cd frontend && npm run build` succeeds
    - ChartContainer imports and uses useMarketDataConnection
    - ConnectionBanner is rendered within the chart area
    - getMockDataForSymbol is still imported as fallback
    - subscribeVisibleLogicalRangeChange is used for infinite scroll
  </verify>
  <done>
    ChartContainer loads real data from backend API, subscribes to WebSocket for live updates, implements infinite scroll for history loading, shows connection banner on disconnect, and falls back to mock data when backend is unreachable. Real-time candle updates are smooth (using series.update). Timeframe switching preserves visible time position.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update watchlist and symbol search for live prices and multi-asset support</name>
  <files>
    frontend/src/components/watchlist/watchlist-item.tsx
    frontend/src/components/watchlist/symbol-search.tsx
  </files>
  <action>
    **1. Update WatchlistItem (`frontend/src/components/watchlist/watchlist-item.tsx`):**
    - Import `useMarketDataStore` from stores/market-data-store
    - Import `getMockDataForSymbol` from lib/mock-data (keep as fallback)
    - Replace the mock price computation:
      - First try: `const liveCandle = useMarketDataStore(s => s.latestPrices.get(symbol))`
      - If liveCandle exists: use `liveCandle.close` as lastPrice
      - For change %: compare liveCandle.close vs liveCandle.open (intra-candle change, which is the best we have from a single candle update)
      - If no live data: fall back to the existing mock data computation
    - Keep the existing `formatPrice` and `formatSymbol` functions
    - Update `formatSymbol` to handle forex format: if symbol contains "/", return as-is (already formatted as EUR/USD per user decision on exchange-native naming)

    **2. Update SymbolSearch (`frontend/src/components/watchlist/symbol-search.tsx`):**
    - Import `FOREX_SYMBOLS` from types/chart
    - Import `detectAssetClass` from types/market-data
    - Add a toggle or auto-detect: when user types a "/" or selects a forex category tab, search against FOREX_SYMBOLS instead of CRYPTO_SYMBOLS
    - Simplest approach: merge both symbol lists for search. Create a combined array:
      ```
      const ALL_SYMBOLS = [
        ...CRYPTO_SYMBOLS.map(s => ({ symbol: s.symbol, name: s.name })),
        ...FOREX_SYMBOLS.map(s => ({ symbol: s.symbol, name: s.name })),
      ]
      ```
    - Filter this combined list based on search input
    - When adding a forex symbol to watchlist, use its symbol string as-is (e.g., "EUR/USD")
    - When switching chart to a forex symbol, the chart store's setSymbol will trigger the data loading effect which detects asset class and routes to the correct provider
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - `cd frontend && npm run build` succeeds
    - WatchlistItem shows live prices when available, mock prices as fallback
    - SymbolSearch includes both crypto and forex symbols
    - formatSymbol handles both "BTCUSDT" -> "BTC/USDT" and "EUR/USD" -> "EUR/USD" correctly
  </verify>
  <done>
    Watchlist items display live prices from WebSocket stream with mock data fallback. Symbol search includes both crypto and forex symbols. Exchange-native naming preserved (BTCUSDT for crypto, EUR/USD for forex).
  </done>
</task>

</tasks>

<verification>
1. Full TypeScript compilation passes (npx tsc --noEmit)
2. Next.js build succeeds (npm run build)
3. Chart loads real data from backend when available, falls back to mock when not
4. Real-time candle updates are visible (series.update, not full setData)
5. Scrolling left past loaded data triggers history fetch and seamless prepend
6. Connection banner appears/disappears based on WebSocket status
7. Watchlist shows live prices, not mock prices, when connected
8. Symbol search includes forex pairs
9. Timeframe switch maintains time position
10. Symbol switch keeps old data visible during load (no flash to empty)
</verification>

<success_criteria>
- Real-time crypto prices update on chart via WebSocket relay
- Real-time forex prices update on chart via polling relay
- Infinite scroll loads history seamlessly when approaching left edge
- Connection banner shows "Connection lost -- reconnecting..." on disconnect, auto-hides on reconnect
- Watchlist items show live prices from WebSocket, falling back to mock data
- Symbol search includes both crypto (~10 hardcoded + dynamic from API) and forex (~25) symbols
- Timeframe switch preserves time position
- Initial load fetches ~500 candles
- No chart dimming/graying on disconnect (banner only)
- Current candle smoothly updates OHLC (series.update, not setData)
</success_criteria>

<output>
After completion, create `.planning/phases/03-market-data-service/03-04-SUMMARY.md`
</output>
